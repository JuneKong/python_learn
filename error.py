#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#name:错误、调试和测试

# *****错误处理*****
# 内置了一套try...except...finally...的错误处理机制
# 
# Python所有的错误都是从BaseException类派生的
# 使用try...except捕获错误还有一个巨大的好处，就是可以跨越多层调用
# 也就是说，不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。
# 
# 调用栈: 如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。
# **出错的时候，一定要分析错误的调用栈信息，才能定位错误的位置。
# 
# 记录错误: logging模块可以非常容易地记录错误信息
# 
# 抛出错误: 用raise语句抛出一个错误的实例
# raise语句后不加参数，会原样抛出错误给上级


# *****调试*****
# 方法：（最大的坏处是将来还得删掉它）
# 1、print()
# 2、断言assert： 格式 => assert 表达式， “错误信息”;
# 		表达式应该为True，否则抛出AssertionError错误：错误信息
# 不过，启动Python解释器时可以用-O参数来关闭assert，关闭后，你可以把所有的assert语句当成pass来看。
# 
# 3、logging(终极武器): 和assert比，logging不会抛出错误，而且可以输出到文件
# 	 logging.info()就可以输出一段文本。
import logging
logging.basicConfig(level=logging.INFO) # =>此时可以知道错误的具体信息

# logging的好处：
#   它允许你指定记录信息的级别，有debug，info，warning，error等几个级别,
#   另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方
# 
# 4、pdb调试器: 让程序以单步方式运行，可以随时查看运行状态。
# 当代码增多会很麻烦
# 	以参数'-m pdb'启动 => pdb定位到下一步要执行的代码
# 	命令'n' => 单步执行代码
# 	命令'p 变量名' => 查看变量
# 	命令'q' => 结束调试，退出程序
# 	命令'c' => 继续运行
# 5、pdb.set_trace(): 我们只需要import pdb，然后，在可能出错的地方放一个pdb.set_trace()，就可以设置一个断点
# 6、IDE: 支持调试功能的IDE

# *****单元测试*****
# 单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。
# 这种以测试为驱动的开发模式最大的好处：
# 就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。
import unittest
# 编写单元测试必须引入Python自带的unittest模块；
# 编写单元测试时，我们需要编写一个测试类，从unittest.TestCase继承。
# 以test开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。
# 
# 由于unittest.TestCase提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。
# 最常用的断言就是assertEqual()
# 另一种重要的断言就是期待抛出指定类型的Error => assertRaises(): 
# with self.assertRaises(KeyError):
# 	  value = d['empty']

# 运行单元测试
# 最简单的运行方式是在文件的最后加上两行代码：
# if __name__ == '__main__':
#     unittest.main()
# 另一种方法：命令行通过参数-m unittest直接运行单元测试（推荐做法，一次批量运行多单元测试）

# setUp与tearDown: 这两个方法会分别在每调用一个测试方法的前后分别被执行。
# 作用：设想你的测试需要启动一个数据库，这时，就可以在setUp()方法中连接数据库，在tearDown()方法中关闭数据库

# 文档测试
# 可以直接提取注释中的代码并执行测试。
# doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用...表示中间一大段烦人的输出。
# 测试正确则无输出